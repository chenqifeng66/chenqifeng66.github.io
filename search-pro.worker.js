const g=(o,a)=>{const i=o.toLowerCase(),e=a.toLowerCase(),s=[];let n=0,l=0;const c=(t,p=!1)=>{let r="";l===0?r=t.length>20?`… ${t.slice(-20)}`:t:p?r=t.length+l>100?`${t.slice(0,100-l)}… `:t:r=t.length>20?`${t.slice(0,20)} … ${t.slice(-20)}`:t,r&&s.push(r),l+=r.length,p||(s.push(["strong",a]),l+=a.length,l>=100&&s.push(" …"))};let h=i.indexOf(e,n);if(h===-1)return null;for(;h>=0;){const t=h+e.length;if(c(o.slice(n,h)),n=t,l>100)break;h=i.indexOf(e,n)}return l<100&&c(o.slice(n),!0),s},d=Object.entries,y=Object.keys,f=o=>o.reduce((a,{type:i})=>a+(i==="title"?50:i==="heading"?20:i==="custom"?10:1),0),$=(o,a)=>{var i;const e={};for(const[s,n]of d(a)){const l=((i=a[s.replace(/\/[^\\]*$/,"")])==null?void 0:i.title)||"",c=`${l?`${l} > `:""}${n.title}`,h=g(n.title,o);h&&(e[c]=[...e[c]||[],{type:"title",path:s,display:h}]),n.customFields&&d(n.customFields).forEach(([t,p])=>{p.forEach(r=>{const u=g(r,o);u&&(e[c]=[...e[c]||[],{type:"custom",path:s,index:t,display:u}])})});for(const t of n.contents){const p=g(t.header,o);p&&(e[c]=[...e[c]||[],{type:"heading",path:s+(t.slug?`#${t.slug}`:""),display:p}]);for(const r of t.contents){const u=g(r,o);u&&(e[c]=[...e[c]||[],{type:"content",header:t.header,path:s+(t.slug?`#${t.slug}`:""),display:u}])}}}return y(e).sort((s,n)=>f(e[s])-f(e[n])).map(s=>({title:s,contents:e[s]}))},m=JSON.parse("{\"/\":{\"/components/Icon.html\":{\"title\":\"Icon\",\"contents\":[{\"header\":\"实现\",\"slug\":\"实现\",\"contents\":[]},{\"header\":\"1. 生成所需图标的 symbol 代码文件\",\"slug\":\"_1-生成所需图标的-symbol-代码文件\",\"contents\":[\"使用阿里巴巴矢量图标库 iconfont\"]},{\"header\":\"2. 导入生成的文件 iconfont.js 到组件下的 font 目录中\",\"slug\":\"_2-导入生成的文件-iconfont-js-到组件下的-font-目录中\",\"contents\":[\"src ┣ components ┣ icon ┣ font ┃ ┗ iconfont.js ┣ style ┃ ┗ index.less ┗ Icon.vue \"]},{\"header\":\"3. 引入 ./font/iconfont.js 文件\",\"slug\":\"_3-引入-font-iconfont-js-文件\",\"contents\":[\"// Icon.vue import \\\"./font/iconfont.js\\\"; \"]},{\"header\":\"4. 添加 svg html 结构\",\"slug\":\"_4-添加-svg-html-结构\",\"contents\":[\"<template> <svg class=\\\"icon\\\" aria-hidden=\\\"true\\\" :style=\\\"`height:${size};width:${size};`\\\"> <use :xlink:href=\\\"iconName\\\"></use> </svg> </template> \"]},{\"header\":\"5. 添加 Icon 的默认样式\",\"slug\":\"_5-添加-icon-的默认样式\",\"contents\":[\"/* index.less */ .icon { width: 1em; height: 1em; vertical-align: -0.15em; fill: currentColor; overflow: hidden; } \"]},{\"header\":\"6. 定义组件所需属性\",\"slug\":\"_6-定义组件所需属性\",\"contents\":[\"// Icon.vue const props = defineProps({ name: { type: String, required: true, }, size: { type: String, }, }); \"]},{\"header\":\"7. 通过计算属性将传入的 name 属性转为实际图标名称\",\"slug\":\"_7-通过计算属性将传入的-name-属性转为实际图标名称\",\"contents\":[\"// Icon.vue import { computed } from \\\"vue\\\"; const iconName = computed(() => \\\"#icon-\\\" + props.name); \"]},{\"header\":\"效果\",\"slug\":\"效果\",\"contents\":[\"🌰\",\"<Icon name=\\\"lizi\\\" size=\\\"1rem\\\" /> \"]}]},\"/git/commit%E6%97%B6%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%BB%A3%E7%A0%81.html\":{\"title\":\"commit 时格式化代码\",\"contents\":[{\"header\":\"安装 husky\",\"slug\":\"安装-husky\",\"contents\":[\"husky：创建 git hook 的工具\",\"pnpm add husky -D \"]},{\"header\":\"启用 git hook\",\"slug\":\"启用-git-hook\",\"contents\":[\"pnpm husky install # npx husky install \",\"该命令作用：\",\"会创建 .husky 目录\",\"设置所在项目本地环境存放 git hook 脚本的目录位置 core.hookspath = .husky\",\"可通过 git config --local --list 查看 git 本地配置\"]},{\"header\":\"添加 npm 生命周期\",\"slug\":\"添加-npm-生命周期\",\"contents\":[\"// package.json \\\"scripts\\\": { \\\"dev\\\": \\\"vite\\\", \\\"build\\\": \\\"vite build\\\", \\\"serve\\\": \\\"vite preview\\\", \\\"prepare\\\": \\\"husky install\\\" }, \",\"prepare：在 npm install 之后执行\",\"作用：在重新拉取代码执行 npm install 时自动启用 git hook\"]},{\"header\":\"安装 prettier\",\"slug\":\"安装-prettier\",\"contents\":[\"prettier：格式化代码工具\",\"pnpm add prettier -D \",\"格式化命令：pnpm prettier --write 目录名 or npx prettier --write 目录名\"]},{\"header\":\"安装 lint-staged\",\"slug\":\"安装-lint-staged\",\"contents\":[\"lint-staged：暂存区文件格式化工具\",\"pnpm add lint-staged -D \"]},{\"header\":\"添加 lint-staged 命令\",\"slug\":\"添加-lint-staged-命令\",\"contents\":[\"// package.json \\\"lint-staged\\\":{ \\\"*.{js,vue}\\\": \\\"prettier --write\\\" // 对 js、vue 文件进行格式化 } \"]},{\"header\":\"创建 git hook\",\"slug\":\"创建-git-hook\",\"contents\":[\"pnpm husky add .husky/pre-commit \\\"pnpm lint-staged —-allow—-empty\\\" # npx husky add .husky/pre-commit \\\"npx lint-staged -—allow—-empty\\\" \",\"该命令作用：\",\"在 .husky 目录下添加 pre-commit 文件\",\"写入内容 pnpm lint-staged —-allow-—empty\",\"注：--allow--empty 当撤回 commit 时允许空提交，否则撤回 commit 会报错\"]},{\"header\":\"总流程\",\"slug\":\"总流程\",\"contents\":[\"commit 后触发 pre-commit (git hook) 钩子\",\"执行 pnpm lint-staged —allow--empty\",\"通过 package.json 的 lint-staged 对所选文件执行格式化\"]}]},\"/git/%E4%BF%AE%E6%94%B9commit.html\":{\"title\":\"修改 commit\",\"contents\":[{\"header\":\"只修改最后一次 commit\",\"slug\":\"只修改最后一次-commit\",\"contents\":[\"git commit --amend \",\"注意\",\"如果修改的是已 push 的 commit，此时 push 会提示远程分支有更新，不要 git pull !!!\",\"# 强制推送 git push -f \"]},{\"header\":\"修改多个 commit\",\"slug\":\"修改多个-commit\",\"contents\":[\"修改最近的两个 commit\",\"git rebase -i HEAD~2 \",\"在交互界面将 pick 修改为 reword\",\"# 最新commit的上一个commit - pick e3e3da3 feat: 抢购订单已购优惠券显示 + reword e3e3da3 feat: 抢购订单已购优惠券显示 # 最新commit - pick 1d4b8d6 fix: 抢购订单详情已购优惠券为空读取不到length属性问题 + reword 1d4b8d6 fix: 抢购订单详情已购优惠券为空读取不到length属性问题 \",\"在交互界面依次修改 commit\",\"# 修改 commit - feat: 抢购订单已购优惠券显示 + feat: 已购优惠券显示 \",\"注意\",\"如果修改的是已 push 的 commit，此时 push 会提示远程分支有更新，不要 git pull !!!\",\"# 强制推送 git push -f \"]}]},\"/git/%E5%90%88%E5%B9%B6commit.html\":{\"title\":\"合并 commit\",\"contents\":[{\"header\":\"合并未 push 的 commit\",\"slug\":\"合并未-push-的-commit\",\"contents\":[\"查看 commit 记录\",\"git log \",\"commit 1d4b8d613b8eb34ce1483521c71fb18736851c63 (HEAD -> main, origin/main, origin/HEAD) Author: chenqifeng66 <839860616@qq.com> Date: Sat Jul 1 11:04:51 2023 +0800 fix: 抢购订单详情已购优惠券为空读取不到length属性问题 commit e3e3da3b3670b91243d733d615c4778dc9e16451 Author: chenqifeng66 <839860616@qq.com> Date: Sat Jul 1 10:54:39 2023 +0800 feat: 抢购订单已购优惠券显示 commit b284b9067e4b0bfd65800b169fc46692f38b8258 Merge: a32cf12 8b12c1b Author: leebo <me@bobo.im> Date: Fri Jun 30 16:46:48 2023 +0800 Merge branch 'main' of github.com:lindo0/shequ_front \",\"合并最近两个 commit\",\"# 从HEAD版本开始往过数2个版本 git rebase -i HEAD~2 # 合并指定版本号（不包含此版本） git rebase -i [commitid] \",\"说明:\",\"-i: 弹出交互式的界面进行编辑合并\",\"[commitid]: 要合并多个版本之前的版本号，注意: [commitid] 本身不参与合并\",\"指定合并 commit\",\"将要被合并的 commit 的 pick 改为 f\",\"# 最新commit的上一个commit pick e3e3da3 feat: 抢购订单已购优惠券显示 # 最新commit - pick 1d4b8d6 fix: 抢购订单详情已购优惠券为空读取不到length属性问题 + f 1d4b8d6 fix: 抢购订单详情已购优惠券为空读取不到length属性问题 # 变基 b284b90..1d4b8d6 到 b284b90（2 个提交） # # 命令: # p, pick <提交> = 使用提交 # r, reword <提交> = 使用提交，但编辑提交说明 # e, edit <提交> = 使用提交，但停止以便在 shell 中修补提交 # s, squash <提交> = 使用提交，但挤压到前一个提交 # f, fixup [-C | -c] <提交> = 类似于 \\\"squash\\\"，但只保留前一个提交 # 的提交说明，除非使用了 -C 参数，此情况下则只 # 保留本提交说明。使用 -c 和 -C 类似，但会打开 # 编辑器修改提交说明 # x, exec <命令> = 使用 shell 运行命令（此行剩余部分） # b, break = 在此处停止（使用 'git rebase --continue' 继续变基） # d, drop <提交> = 删除提交 # l, label <label> = 为当前 HEAD 打上标记 # t, reset <label> = 重置 HEAD 到该标记 # m, merge [-C <commit> | -c <commit>] <label> [# <oneline>] # . 创建一个合并提交，并使用原始的合并提交说明（如果没有指定 # . 原始提交，使用注释部分的 oneline 作为提交说明）。使用 # . -c <提交> 可以编辑提交说明。 # # 可以对这些行重新排序，将从上至下执行。 \",\"跳过冲突(如果有)\",\"git rebase --skip \"]},{\"header\":\"合并已 push 的 commit\",\"slug\":\"合并已-push-的-commit\",\"contents\":[\"查看 commit 记录\",\"git log \",\"合并最近两个 commit\",\"git rebase -i HEAD~2 \",\"指定合并 commit\",\"# 最新commit的上一个commit pick e3e3da3 feat: 抢购订单已购优惠券显示 # 最新commit - pick 1d4b8d6 fix: 抢购订单详情已购优惠券为空读取不到length属性问题 + f 1d4b8d6 fix: 抢购订单详情已购优惠券为空读取不到length属性问题 \",\"跳过冲突(如果有)\",\"git rebase --skip \",\"强制推送\",\"注意\",\"此时 push 会提示远程分支有更新 不要 git pull !!!\",\"# 强制推送 git push -f \"]},{\"header\":\"取消合并\",\"slug\":\"取消合并\",\"contents\":[\"git rebase --abort \"]}]},\"/intro/\":{\"title\":\"介绍\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"这是一个使用 Vuepress 搭建的个人博客。\"]},{\"header\":\"为什么搭建\",\"slug\":\"为什么搭建\",\"contents\":[\"记录前端知识\"]},{\"header\":\"关于我\",\"slug\":\"关于我\",\"contents\":[\"一个在前端之路上前进的菜鸟 🦊\"]}]},\"/javascript/%E5%88%A4%E6%96%AD%E4%BC%A0%E5%85%A5%E7%9A%84%E5%87%BD%E6%95%B0%E6%98%AF%E5%90%A6%E6%A0%87%E8%AE%B0%E4%BA%86async.html\":{\"title\":\"判断传入的函数是否标记了 async\",\"contents\":[{\"header\":\"题目\",\"slug\":\"题目\",\"contents\":[\"写一个函数来判断传入的函数是否标记了 async\"]},{\"header\":\"示例\",\"slug\":\"示例\",\"contents\":[\"function isAsyncFunction(func) {} isAsyncFunction(() => {}); // expect: false isAsyncFunction(async () => {}); // expect: true \"]},{\"header\":\"解决方法\",\"slug\":\"解决方法\",\"contents\":[\"在 async 标记的函数原型上有一个 Symbol.toStringTag 属性\",\"console.dir(async function () {}); /* expect: ... [[Prototype]]: AsyncFunction constructor: f AsyncFunction() Symbol(Symbol.toStringTag): \\\"AsyncFunction\\\" ... */ \",\"通过判断 Symbol.toStringTag 属性即可知道传入函数是否为 async 标记的函数\",\"function isAsyncFunction(func) { return func[Symbol.toStringTag] === \\\"AsyncFunction\\\"; } \"]}]},\"/javascript/%E6%B7%B1%E6%8B%B7%E8%B4%9D.html\":{\"title\":\"深拷贝\",\"contents\":[{\"header\":\"实现\",\"slug\":\"实现\",\"contents\":[\"function deepClone(source) { if (typeof source !== \\\"object\\\" || source === null) { return source; } if (source instanceof Date) return new Date(source); if (source instanceof Set) return new Set(Array.from(source)); if (source instanceof Map) return new Map(source.entries()); const target = Array.isArray(source) ? [] : {}; for (const key in source) { // 不克隆原型上的属性和方法 if (Object.prototype.hasOwnProperty.call(source, key)) { // 解决循环引用问题 if (source[key] === source) { target[key] = source; } else { target[key] = deepClone(source[key]); } } } return target; } \"]}]},\"/typescript/%E5%BC%95%E5%85%A5%E5%9B%BE%E7%89%87%E6%8A%A5%E9%94%99.html\":{\"title\":\"引入图片报错\",\"contents\":[{\"header\":\"问题\",\"slug\":\"问题\",\"contents\":[\"// 报错：找不到 @/assets/img-1.png 的声明 import png from \\\"@/assets/img-1.png\\\"; \"]},{\"header\":\"原因\",\"slug\":\"原因\",\"contents\":[\"typescript 默认只检查代码文件，无法识别非代码文件\"]},{\"header\":\"解决\",\"slug\":\"解决\",\"contents\":[\"新建 src/typings/images.d.ts 文件，声明非代码文件\",\"declare module \\\"*.svg\\\"; declare module \\\"*.png\\\"; declare module \\\"*.jpg\\\"; declare module \\\"*.jpeg\\\"; declare module \\\"*.gif\\\"; declare module \\\"*.bmp\\\"; declare module \\\"*.tiff\\\"; \",\"在 tsconfig.json 文件中声明编译包含该文件\",\"{ \\\"compilerOptions\\\": { // ... }, \\\"include\\\": [\\\"src/typings/images.d.ts\\\"] } \"]}]},\"/typescript/%E8%B7%AF%E5%BE%84%E5%88%AB%E5%90%8D%E6%8A%A5%E9%94%99.html\":{\"title\":\"路径别名报错\",\"contents\":[{\"header\":\"问题\",\"slug\":\"问题\",\"contents\":[\"// 报错: Cannot find module '@/xxx/xxx' import { xxx } from \\\"@/xxx/xxx' \"]},{\"header\":\"原因\",\"slug\":\"原因\",\"contents\":[\"typescript 无法识别路径别名\"]},{\"header\":\"解决\",\"slug\":\"解决\",\"contents\":[\"{ \\\"compilerOptions\\\": { \\\"paths\\\": { \\\"@/*\\\": [\\\"src/*\\\"] } } } \"]}]},\"/%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF/h5%E8%B7%B3%E8%BD%AC%E5%B0%8F%E7%A8%8B%E5%BA%8F.html\":{\"title\":\"公众号h5跳转小程序\",\"contents\":[{\"header\":\"场景\",\"slug\":\"场景\",\"contents\":[\"在微信公众号 H5 项目中实现 点击按钮跳转到拼多多小程序 功能\"]},{\"header\":\"实现\",\"slug\":\"实现\",\"contents\":[\"官方文档\",\"绑定域名\",\"登录微信公众平台进入 公众号设置 的 功能设置 里填写 JS接口安全域名。\",\"引入 js 文件\",\"在需要调用 JS 接口的页面引入如下 JS 文件：http://res.wx.qq.com/open/js/jweixin-1.6.0.js （支持 https）\",\"如需进一步提升服务稳定性，当上述资源不可访问时，可改访问：http://res2.wx.qq.com/open/js/jweixin-1.6.0.js （支持 https）\",\"备注：支持使用 AMD/CMD 标准模块加载方法加载。\",\"通过 config 接口注入权限验证配置并申请所需开放标签\",\"wx.config({ debug: true, // 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印 appId: '', // 必填，公众号的唯一标识 timestamp: , // 必填，生成签名的时间戳 nonceStr: '', // 必填，生成签名的随机串 signature: '',// 必填，签名 jsApiList: [], // 必填，需要使用的JS接口列表 openTagList: [] // 可选，需要使用的开放标签列表，例如['wx-open-launch-app'] }); \",\"通过 ready 接口处理成功验证\",\"wx.ready(function () { // config信息验证后会执行ready方法， // 所有接口调用都必须在config接口获得结果之后， // config是一个客户端的异步操作， // 所以如果需要在页面加载时就调用相关接口，则须把相关接口放在ready函数中调用来确保正确执行。 // 对于用户触发时才调用的接口，则可以直接调用，不需要放在ready函数中 }); \",\"通过 error 接口处理失败验证\",\"wx.error(function (res) { // config信息验证失败会执行error函数 // 如签名过期导致验证失败，具体错误信息可以打开config的debug模式查看， // 也可以在返回的res参数中查看，对于SPA可以在这里更新签名 }); \",\"使用微信的开发标签 wx-open-launch-weapp\",\"<wx-open-launch-weapp appid=\\\"所需跳转的小程序appid\\\" path=\\\"所需跳转的小程序内页面路径及参数\\\" username=\\\"所需跳转的小程序原始id（跳转时，有appid会优先使用appid，没有appid才会使用username）\\\" @launch=\\\"用户点击跳转按钮并对确认弹窗进行操作后触发;\\\" @error=\\\"用户点击跳转按钮后出现错误;\\\" > <component :is=\\\"'script'\\\" type=\\\"text/wxtag-template\\\"> <!-- 内容 --> <button>点击跳转小程序</button> </component> </wx-open-launch-weapp> \"]}]},\"/%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF/%E9%98%BF%E9%87%8C%E4%BA%91%E9%83%A8%E7%BD%B2%E6%9C%AC%E5%8D%9A%E5%AE%A2.html\":{\"title\":\"阿里云部署本博客\",\"contents\":[{\"header\":\"准备工作\",\"slug\":\"准备工作\",\"contents\":[\"服务器: 阿里云 Alibaba Cloud Linux 3.2104 LTS 64 位\",\"服务器包: nginxzipunzip\"]},{\"header\":\"nginx 配置\",\"slug\":\"nginx-配置\",\"contents\":[\"查看配置文件\",\"nginx -t # nginx: the configuration file /etc/nginx/nginx.conf syntax is ok # nginx: configuration file /etc/nginx/nginx.conf test is successful \",\"修改配置文件\",\"vim /etc/nginx/nginx.conf \",\"# user nginx; user root; # 设置用户 访问首页出现403说明权限不够 worker_processes auto; error_log /var/log/nginx/error.log; pid /run/nginx.pid; server { listen 80; listen [::]:80; server_name 47.115.215.103; # Ip / 域名 charset utf-8; root /root/home/www/vuepress/dist; # 首页路径 } \",\"重启 nginx\",\"nginx -s reload \"]},{\"header\":\"部署流程\",\"slug\":\"部署流程\",\"contents\":[]},{\"header\":\"1. 本地 build 代码\",\"slug\":\"_1-本地-build-代码\",\"contents\":[]},{\"header\":\"2. 压缩 dist 文件夹\",\"slug\":\"_2-压缩-dist-文件夹\",\"contents\":[]},{\"header\":\"3. 将压缩后的 dist.zip 传输到服务器\",\"slug\":\"_3-将压缩后的-dist-zip-传输到服务器\",\"contents\":[\"# mac ftp 传输 put <本地 dist.zip 路径> <服务器路径> # window Xshell \"]},{\"header\":\"4. 服务器解压 dist.zip 到指定目录\",\"slug\":\"_4-服务器解压-dist-zip-到指定目录\",\"contents\":[\"# 进入到 dist.zip 所在目录 cd <dist.zip所在目录> # 解压 unzip -o dist.zip \"]}]},\"/css/case/Switch.html\":{\"title\":\"Switch\",\"contents\":[{\"header\":\"效果\",\"slug\":\"效果\",\"contents\":[]},{\"header\":\"实现思路\",\"slug\":\"实现思路\",\"contents\":[\"隐藏 input 的样式\",\"input[type=\\\"checkbox\\\"] { display: none; } \",\"设置背景\",\"label { display: inline-block; width: 50px; height: 20px; background-color: #ccc; border-radius: 20px; position: relative; } \",\"设置小球\",\"label::after { content: \\\"\\\"; width: 16px; height: 16px; position: absolute; background-color: #fff; border-radius: 50%; top: 2px; left: 2px; transition: 0.5s; } \",\"checkbox 选中时改变背景和小球位置\",\"input[type=\\\"checkbox\\\"]:checked ~ label { background-color: #6d9afc; } input[type=\\\"checkbox\\\"]:checked ~ label::after { transform: translateX(30px); } \"]}]},\"/css/case/%E5%8A%A8%E6%95%88%E5%88%97%E8%A1%A8.html\":{\"title\":\"动效列表\",\"contents\":[{\"header\":\"效果\",\"slug\":\"效果\",\"contents\":[]},{\"header\":\"实现思路\",\"slug\":\"实现思路\",\"contents\":[]},{\"header\":\"删除操作\",\"slug\":\"删除操作\",\"contents\":[\"删除元素右移消失，下方元素往上移动一格\",\"定义删除动画和上移动画\",\"/* 往右渐变消失 */ .leave { transition: all 0.5s; transform: translateX(200px); opacity: 0; } /* 往上移动 */ .up { transition: all 0.5s; transform: translateY(-30px); } \",\"模板根据删除元素索引绑定删除动画和上移动画\",\"<div class=\\\"item\\\" v-for=\\\"(item, index) in list\\\" :key=\\\"item.id\\\" :class=\\\"{ leave: delIndex == index, up: delIndex != -1 && delIndex < index, }\\\" ></div> \",\"点击删除按钮指定删除元素索引，删除动画播放完毕后，删除元素\",\"del(index) { // 当前已有元素在执行操作，退出 if (this.isHandle) return; this.delIndex = index; setTimeout(() => { this.list.splice(index, 1); this.delIndex = -1; }, this.animationTime); } \"]},{\"header\":\"置顶操作\",\"slug\":\"置顶操作\",\"contents\":[\"置顶元素移到最上方，上方元素往下移动一格\",\"定义下移动画（置顶动画需要手动计算移动距离）\",\"/* 往下移动 */ .down { transition: all 0.5s; transform: translateY(30px); } \",\"模板根置顶元素索引绑定下移动画\",\"<div class=\\\"item\\\" v-for=\\\"(item, index) in list\\\" :key=\\\"item.id\\\" :class=\\\"{ down: topIndex > index, }\\\" ></div> \",\"点击置顶按钮指定置顶元素索引，计算置顶需要移动的距离(索引 * 元素高度),绑定置顶动画，动画播放完毕后，移动元素\",\"top(index) { // 当前已有元素在执行操作，退出 if (this.isHandle) return; this.topIndex = index; // 置顶动画 this.nowHandleNode.style.transition = \\\"all 0.5s\\\"; this.nowHandleNode.style.transform = `translateY(-${30 * index}px)`; setTimeout(() => { // 移除置顶动画 this.nowHandleNode.style.transition = \\\"\\\"; this.nowHandleNode.style.transform = \\\"\\\"; // 移动元素 const item = this.list[index]; this.list.splice(index, 1); this.list.unshift(item); this.topIndex = -1; }, this.animationTime); } \"]},{\"header\":\"添加操作\",\"slug\":\"添加操作\",\"contents\":[\"定义添加动画\",\"/* 从右方渐变进入 */ .from { animation: 0.5s linear 1 from; } @keyframes from { 0% { transform: translateX(50px); opacity: 0; } 100% { transform: none; opacity: 1; } } \",\"点击添加按钮，添加元素，DOM 渲染后绑定添加动画，动画播放完毕后，移除样式\",\"add() { if (!this.inputValue.trim()) return; // 添加元素 this.list.push({ id: (this.list.length + 1).toString(), content: this.inputValue.trim(), }); this.inputValue = \\\"\\\"; this.$nextTick(() => { // this.$refs.listRef.children[this.list.length - 1] 最后一个元素 this.$refs.listRef.children[this.list.length - 1]. classList.add(\\\"from\\\"); setTimeout(() => { this.$refs.listRef.children[this.list.length - 1]. classList.remove(\\\"from\\\"); }, this.animationTime); }); } \"]}]},\"/css/case/%E5%9C%86%E8%A7%92%E8%8F%9C%E5%8D%95%E6%A0%8F.html\":{\"title\":\"圆角菜单栏\",\"contents\":[{\"header\":\"效果\",\"slug\":\"效果\",\"contents\":[]},{\"header\":\"实现思路\",\"slug\":\"实现思路\",\"contents\":[\"外层容器圆角\",\"ul { /* 顺时针 从左上角开始 */ border-radius: 10px 10px 0 0; } \",\"选中的导航栏添加圆角\",\".active { /* 顺时针 从左上角开始 */ border-radius: 10px 10px 0 0; } \",\"选中的导航栏添加阴影\",\".active { box-shadow: 12px 12px 0 0 #fff, -12px 12px 0 0 #fff; } \",\"选中的导航栏左右添加伪元素绝对定位盖住阴影\",\".active::before { content: \\\"\\\"; position: absolute; left: -12px; bottom: 0; width: 12px; height: 42.5px; /* ul 背景色 */ background-color: #e2e8f8; border-bottom-right-radius: 10px; } .active::after { content: \\\"\\\"; position: absolute; right: -12px; bottom: 0; width: 12px; height: 42.5px; /* ul 背景色 */ background-color: #e2e8f8; border-bottom-left-radius: 10px; } \",\"超出隐藏\",\"ul { overflow: hidden; } \"]}]},\"/css/case/%E7%80%91%E5%B8%83%E6%B5%81.html\":{\"title\":\"瀑布流\",\"contents\":[{\"header\":\"方式一：column\",\"slug\":\"方式一-column\",\"contents\":[]},{\"header\":\"实现思路\",\"slug\":\"实现思路\",\"contents\":[\"外层容器指定列数\",\".container { /* 列数 */ column-count: 4; /* 每列的间隔 */ column-gap: 0; } \",\"图片撑满容器\",\".item img { width: 100%; } \",\"注意\",\"该方式按竖向排序\"]},{\"header\":\"方式二：flex\",\"slug\":\"方式二-flex\",\"contents\":[]},{\"header\":\"实现思路\",\"slug\":\"实现思路-1\",\"contents\":[\"外层容器指定高度 flex 布局 纵向排列 超出换行\",\".container { display: flex; flex-direction: column; height: 500px; flex-wrap: wrap; } \",\"子元素指定宽度\",\".item { width: 25%; } \",\"子元素根据列数排序\",\"/* 1,5,9,13... 排到第一列 */ .item:nth-child(4n + 1) { order: 1; } /* 2,6,10,14.... 排到第二列 */ .item:nth-child(4n + 2) { order: 2; } /* 3,7,11,15.... 排到第三列 */ .item:nth-child(4n + 3) { order: 3; } /* 4,8,12,16.... 排到第四列 */ .item:nth-child(4n) { order: 4; } \",\"注意\",\"该方式需要指定容器的高度和计算 order\"]}]},\"/css/case/%E7%BF%BB%E9%A1%B5%E6%97%B6%E9%92%9F.html\":{\"title\":\"翻页时钟\",\"contents\":[]},\"/css/case/%E8%BE%B9%E6%A1%86%E6%B5%81%E5%8A%A8.html\":{\"title\":\"边框流动\",\"contents\":[{\"header\":\"效果\",\"slug\":\"效果\",\"contents\":[]},{\"header\":\"实现思路\",\"slug\":\"实现思路\",\"contents\":[\"box 伪元素::before 实现渐变背景\",\".box::before { content: \\\"\\\"; position: absolute; width: 80px; height: 120%; background: linear-gradient(#00ccff, #d500f9); } \",\"box 伪元素::before 实现旋转动画\",\".box::before { animation: rotate 4s linear infinite; } @keyframes rotate { from { transform: rotate(0deg); } to { transform: rotate(360deg); } } \",\"box 伪元素::after 盖住渐变背景\",\".box::after { content: \\\"\\\"; position: absolute; /* 简写用法: 等价于 top:5px; left:5px; bottom:5px; right:5px; */ inset: 5px; background: #0e1538; border-radius: 10px; } \",\"box 超出隐藏\",\".box { overflow: hidden; } \",\"文字调到上层\",\".box h2 { z-index: 1; } \"]}]},\"/javascript/%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/%E5%87%BD%E6%95%B0%E7%BB%84%E5%90%88.html\":{\"title\":\"函数组合\",\"contents\":[{\"header\":\"什么是函数组合\",\"slug\":\"什么是函数组合\",\"contents\":[\"将多个函数组合成一个函数，类似过滤器的作用\",\"compose(fun1,fun2,...)(value) => value | fun1 | fun2 | ...\"]},{\"header\":\"为什么需要函数组合\",\"slug\":\"为什么需要函数组合\",\"contents\":[]},{\"header\":\"🌰\",\"slug\":\"🌰\",\"contents\":[\"处理字符串\",\"function stringToUpper(str) { return str.toUpperCase(); } function stringToArray(str) { return str.split(\\\"\\\"); } const str = \\\"javascript\\\"; const upperStr = stringToUpper(str); // 'JAVASCRIPT' const arrayStr = stringToArray(upperStr); // ['J','A','V','A','S','C','R','I','P','T'] \",\"以上做法虽然方便使用，但会产生很多不必要的变量定义\",\"如果有一个函数能将需要用到的函数组合起来，通过调用组合后的函数得到结果，那就会很方便，而且不需要定义很多不必要的变量\",\"const func = compose(stringToUpper, stringToArray); func(str); // ['J','A','V','A','S','C','R','I','P','T'] \"]},{\"header\":\"实现思路\",\"slug\":\"实现思路\",\"contents\":[\"函数组合逻辑：\",\"接收多个函数作为参数\",\"返回一个函数\",\"调用返回的函数时，依次调用传入函数\",\"function compose(...args) { // args：函数参数 return function (value) { // arg：第一次为传入的参数(str),第二次为第一个函数的执行结果... return args.reduce((arg, func) => func(arg), value); }; } \",\"从右往左执行可将 reduce 改为 reduceRight\"]},{\"header\":\"总结\",\"slug\":\"总结\",\"contents\":[\"函数组合可以将多个负责单一功能的函数组合在一起，形成一个新的多功能函数\"]}]},\"/javascript/%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/%E6%9F%AF%E9%87%8C%E5%8C%96.html\":{\"title\":\"柯里化（Currying）\",\"contents\":[{\"header\":\"什么是柯里化\",\"slug\":\"什么是柯里化\",\"contents\":[\"柯里化是一种函数的转换方法\",\"它是将一个函数从可调用的 f(a,b,c) 转换为可调用的 f(a)(b)(c)\"]},{\"header\":\"为什么需要柯里化\",\"slug\":\"为什么需要柯里化\",\"contents\":[\"可以固定前几个参数，生成实现部分功能的函数\"]},{\"header\":\"🌰\",\"slug\":\"🌰\",\"contents\":[\"一个日志函数\",\"function log(date, type, message) { const hour = date.getHours(); const month = date.getMonths(); return `${hour}:${month} ${type} ${message}`; } log(new Date(), \\\"DEBUG\\\", \\\"some bug\\\"); // hh:mm DEBUG some bug \",\"柯里化 - 部分功能函数\",\"const curryLog = curry(log); // 固定日期的日志函数 const logNow = curryLog(new Date()); logNow(\\\"DEBUG\\\", \\\"some bug\\\"); // hh:mm DEBUG some bug // 固定日期、类型的日志函数 const logNowDebug = curryLog(new Date(), \\\"DEBUG\\\"); logNowDebug(\\\"some bug\\\"); // hh:mm DEBUG some bug \"]},{\"header\":\"简单实现\",\"slug\":\"简单实现\",\"contents\":[\"一个简单的加法函数\",\"function sum(a, b, c) { return a + b + c; } \",\"将 sum(1,2,3) 函数转为 sum(1)(2)(3) 调用\"]},{\"header\":\"思考\",\"slug\":\"思考\",\"contents\":[\"柯里化函数逻辑：\",\"接收一个函数\",\"返回一个函数/调用原函数的结果 \",\"返回一个函数：在最后一个参数之前\",\"返回调用原函数的结果：在最后一个参数的时候\",\"function curry(func) { return function (a) { return function (b) { return function (c) { func(a, b, c); }; }; }; } const currySum = curry(sum); currySum(1)(2)(3); // 6 \",\"从以上代码的实现可以看出，原函数接收多少个参数，curry 函数就得返回多少层\",\"function curry(func) { return function (a) { return function (b) { // .... 最终调用原函数 }; }; } \"]},{\"header\":\"存在的问题\",\"slug\":\"存在的问题\",\"contents\":[\"不灵活，无法通用。curry 函数内部无法根据原函数参数个数来适应\",\"无法以原函数的方式调用柯里化后的函数。既可以以 currySum(1,2,3) 的方式调用，也可以以 currySum(1)(2)(3) 的方式调用\"]},{\"header\":\"改进\",\"slug\":\"改进\",\"contents\":[\"将传入的参数与原函数所需的参数比较 \",\"当传入参数个数多于或等于原函数所需参数时，以原函数方式调用\",\"当传入参数个数少于原函数所需参数时，以柯里化方式调用\",\"核心：收集参数，最终将所有参数传入原函数\",\"function curry(func) { return function curried(...arg1) { // func.length 获取函数所需参数个数 if (arg1.length >= func.length) { // 【传入参数 >= 原函数所需的参数】时则以原函数调用 return func.apply(this, arg1); } else { // 【传入参数 < 原函数所需的参数】以柯里化方式调用 // 返回一个函数，该函数将后续参数拼接，最终以原函数调用 return function (...arg2) { return curried.apply(this, arg1.concat(arg2)); }; } }; } const currySum = curry(sum); currySum(1, 2, 3); // 6 currySum(1, 2)(3); // 6 currySum(1)(2)(3); // 6 \"]},{\"header\":\"总结\",\"slug\":\"总结\",\"contents\":[\"柯里化：把接收多参的函数转化成可以逐个调用单个参数并返回接收剩下参数的函数\",\"应用： 使用柯里化可以更容易获取部分功能函数，如🌰中的【日志函数】\",\"注意：只允许转化确定参数个数的函数\"]}]},\"/vue/vue3/%E6%BA%90%E7%A0%81/mini-vue.html\":{\"title\":\"mini-vue\",\"contents\":[{\"header\":\"前言\",\"slug\":\"前言\",\"contents\":[\"基于前几节的实现，现在已经可以搭建一个 vue 的雏形了。\",\"现在需要实现一个 mount 函数来挂载整个 app\"]},{\"header\":\"思路\",\"slug\":\"思路\",\"contents\":[\"该函数接收两个参数，一个是 App(组件)，一个是要挂载到的节点\",\"App对象 上要有响应式数据，并且要有 虚拟 dom，当虚拟dom依赖的响应式数据发生变化时(即被 watchEffect函数 监听到)，对比 新旧虚拟 dom。\",\"watchEffect(()=>{ if 未挂载 渲染虚拟 dom 挂载真实 dom else 已挂载 重新渲染虚拟 dom 比较新旧虚拟 dom 替换掉旧虚拟 dom }) \"]},{\"header\":\"实现\",\"slug\":\"实现\",\"contents\":[\"App\",\"const App = { data:reactive({ count:0 }), render(){ return { 'div', { onClick:()=>{this.data.count++} }, String(this.data.count) // vue 编译器会对非 array 类型的数据做字符串转换 } } } \",\"mount\",\"function mount(component, container) { let isMounted = false; let preDom; watchEffect(() => { if (!isMounted) { preDom = component.render(); mountDom(preDom, container); isMounted = true; } else { const newDom = component.render(); patch(preDom, newDom); preDom = newDom; } }); } \",\"挂载 App\",\"mount(App, document.getElementById(\\\"app\\\")); \"]},{\"header\":\"总结\",\"slug\":\"总结\",\"contents\":[\"至此，就实现了一个简易版的 vue，符合 MVVM 模式， Model - view - viewModel，定义数据，定义视图，数据修改时通过 vm 驱动视图更新。\"]}]},\"/vue/vue3/%E6%BA%90%E7%A0%81/patch.html\":{\"title\":\"patch\",\"contents\":[{\"header\":\"前言\",\"slug\":\"前言\",\"contents\":[\"上一节实现了 h函数 和 mountDom 函数，最终能将虚拟 DOM 渲染到页面上，这一节将实现 patch函数，来对新旧虚拟 DOM 进行更新替换。\"]},{\"header\":\"patch\",\"slug\":\"patch\",\"contents\":[\"对比 新旧虚拟 dom 并更新视图\"]},{\"header\":\"思路\",\"slug\":\"思路\",\"contents\":[\"if 标签相同 比较 props 添加新 prop 删除旧 prop 比较 children if 旧 chidlren 为 string if 新 children 为 string 比较新旧 children，不同则更新当前节点文本 else 新 children 为 array 清空当前节点下的内容 循环新 children 挂载到当前节点下 else 旧 chidlren 为 array if 新 children 为 string 用新 children 作为当前节点文本替换掉旧内容 else 新 chidlren 为 array 比较相同部分 添加新 child 删除旧 child else 标签不同 直接替换掉旧虚拟 dom \"]},{\"header\":\"实现\",\"slug\":\"实现\",\"contents\":[\"function patch(oldVdom, newVdom) { // same tag if (oldVdom.tag === newVdom.tag) { const el = (newVdom.el = oldVdom.el); // patch props const oldProps = oldVdom.props || {}; const newProps = newVdom.props || {}; // add new prop for (const key in newProps) { const newValue = newProps[key]; const oldValue = oldProps[key]; if (newValue !== oldValue) { el.setAttribute(key, newValue); } } // remove old prop for (const key in oldProps) { if (!(key in newProps)) { el.removeAttribute(key); } } // patch children const oldChildren = oldVdom.children; const newChildren = newVdom.children; if (typeof oldChildren === \\\"string\\\") { if (typeof newChildren === \\\"string\\\") { // oldChildren: string newChildren: string if (oldChildren !== newChildren) { el.textContent = newChildren; } } else { // oldChildren: string newChildren: array el.innerHTML = \\\"\\\"; newChildren.forEach((child) => { mountDom(child, el); }); } } else { if (typeof newChildren === \\\"string\\\") { // oldChildren: array newChildren: string // clear old node el.textContent = newChildren; } else { // oldChildren: array newChildren: array // patch common const commonLength = Math.min(oldChildren.length, newChildren.length); for (let i = 0; i < commonLength; i++) { patch(oldChildren[i], newChildren[i]); } // add new child if (newChildren.length > oldChildren.length) { newChildren.slice(oldChildren.length).forEach((child) => { mountDom(child, el); }); } // remove old child if (newChildren.length < oldChildren.length) { oldChildren.slice(newChildren.length).forEach((child) => { el.removeChild(child.el); }); } } } } else { // replace // get parent node const container = oldVdom.el.parentNode; // clear current node container.innerHTML = \\\"\\\"; // mount mountDom(newVdom, container); } } \"]},{\"header\":\"总结\",\"slug\":\"总结\",\"contents\":[\"结合上一节的 h函数 和 mountDom函数\",\"const vdom = h(\\\"div\\\", null, \\\"hello\\\"); mountDom(vdom, document.getElementById(\\\"app\\\")); \",\"更新虚拟 DOM，页面更新\",\"const newVdom = h(\\\"span\\\", { class: \\\"red\\\" }, \\\"world\\\"); patch(vdom, newVdom); \",\"截止目前为止，可以实现手动更新视图，下一节将实现 watchEffect函数，来收集和触发依赖\"]}]},\"/vue/vue3/%E6%BA%90%E7%A0%81/reactive.html\":{\"title\":\"reactive\",\"contents\":[{\"header\":\"前言\",\"slug\":\"前言\",\"contents\":[\"上一节实现的类无法实现对引用类型数据的操作捕获，所以这一节使用 Proxy 来实现对引用类型数据的操作捕获。\",\"Vue2 使用的是 Object.defineProperty实现\",\"Vue3 使用的是 Proxy实现\"]},{\"header\":\"dep\",\"slug\":\"dep\",\"contents\":[\"修改一下上一节实现的 dep 类，移除 value 属性和 gettersetter\",\"let activeEffect; class Dep { subscribers = new Set(); depend() { if (activeEffect) { this.subscribers.add(activeEffect); } } notify() { this.subscribers.forEach((effect) => { effect(); }); } } \"]},{\"header\":\"reactive\",\"slug\":\"reactive\",\"contents\":[\"在 vue3 中，reactive 函数接收的是一个引用类型的数据，使之具有响应式。\"]},{\"header\":\"思路\",\"slug\":\"思路\",\"contents\":[\"接收引用类型的数据; 返回数据的代理; \"]},{\"header\":\"实现\",\"slug\":\"实现\",\"contents\":[\"// WeakMap：只接受 object 作为 key；当 key 不被引用时，该 key 也就随之清除（垃圾回收） const targetsMap = new WeakMap(); // 记录所有响应式对象的依赖 /** * @description: 获取指定值的 Dep 实例(记录着该值的所有依赖) * @param target 目标对象 * @param key 键 * @return {object} dep */ function getDep(target, key) { let depsMap = targetsMap.get(target); if (!depsMap) { depsMap = new Map(); targetsMap.set(target, depsMap); } let dep = depsMap.get(key); if (!dep) { dep = new Dep(); depsMap.set(key, dep); } return dep; } // 拦截器 const reactiveHandlers = { // receiver 解决 this 指向问题 get(target, key, receiver) { const dep = getDep(target, key); // 收集依赖 dep.depend(); return Reflect.get(target, key, receiver); }, set(target, key, value, receiver) { const result = Reflect.set(target, key, value, receiver); const dep = getDep(target, key); // 触发依赖 dep.notify(); return result; }, }; /** * @description: 创建响应式对象 * @param raw 要代理的对象 * @return {object} proxy */ function reactive(raw) { return new Proxy(raw, reactiveHandlers); } \"]},{\"header\":\"创建响应式对象\",\"slug\":\"创建响应式对象\",\"contents\":[\"const state = reactive({ count: 1, }); watchEffect(() => { console.log(state.count); }); state.count++; // 2 \"]},{\"header\":\"总结\",\"slug\":\"总结\",\"contents\":[\"响应式的原理\",\"访问属性时收集依赖\",\"修改属性时触发依赖\"]}]},\"/vue/vue3/%E6%BA%90%E7%A0%81/vdom.html\":{\"title\":\"vdom\",\"contents\":[{\"header\":\"前言\",\"slug\":\"前言\",\"contents\":[\"使用 vue3 也有一段时间，过程中碎片式地学习了一些 vue3 原理相关的知识，但还是对 vue3 的整个逻辑不是很清楚，所以试着实现一下 mini-vue 以加深对 vue3 的理解。\"]},{\"header\":\"虚拟 dom\",\"slug\":\"虚拟-dom\",\"contents\":[\"虚拟 DOM: Virtual DOM，即用 js 对象描述真实 DOM。\",\"真实 DOM\",\"<div>hello</div> \",\"虚拟 DOM\",\"{ tag:'div', // 标签名 props:{}, // 属性和事件 children: 'hello' // 子节点 string | array } \"]},{\"header\":\"渲染挂载流程\",\"slug\":\"渲染挂载流程\",\"contents\":[\"vue3的初始流程为\",\"创建虚拟 DOM\",\"将虚拟 DOM 渲染为真实 DOM\",\"将真实 DOM 挂载到页面容器上（ #app ）\"]},{\"header\":\"h\",\"slug\":\"h\",\"contents\":[\"生成 虚拟dom 对象\",\"/** * @description: 生成虚拟 dom * @param {string} tag html 标签名 * @param {object} props 属性及事件 * @param {string | array} children 子节点 * @return {object} 虚拟dom */ function h(tag, props, children) { return { tag, props, children, }; } \",\"虚拟 dom\",\"h(\\\"div\\\", null, \\\"hello\\\"); // { tag: 'div', props: null , children: 'hello' } \"]},{\"header\":\"mountDom\",\"slug\":\"mountdom\",\"contents\":[\"将 虚拟dom 渲染为 真实dom\"]},{\"header\":\"思路\",\"slug\":\"思路\",\"contents\":[\"用虚拟 dom 创建真实 dom if 虚拟 dom 存在 props 属性 遍历 props if prop 是事件 给真实 dom 绑定事件 else prop 是属性 给真实 dom 添加属性 if 虚拟 dom 存在 children 属性 if children 为 string 将 children 设为真实 dom 的文本 else children 为 array 调用本函数生成真实 dom 将真实 dom 追加到 container 中 \"]},{\"header\":\"实现\",\"slug\":\"实现\",\"contents\":[\"/** * @description: * @param {object} vdom 虚拟 dom * @param {object} container 挂载节点 * @return {*} */ function mountDom(vdom, container) { // real dom const el = (vdom.el = document.createElement(vdom.tag)); // props if (vdom.props) { for (const key in vdom.props) { const value = vdom.props[key]; // event if (key.startsWith(\\\"on\\\")) { el.addEventListener(key.slice(2).toLowerCase(), value); } else { // attribute el.setAttribute(key, value); } } } // children if (vdom.children) { if (typeof vdom.children === \\\"string\\\") { el.textContent = vdom.children; } else { vdom.children.forEach((child) => { mountDom(child, el); }); } } // add el to the end of the container container.appendChild(el); } \",\"生成真实 dom\",\"const vdom = h(\\\"div\\\", null, \\\"hello\\\"); mountDom(vdom, document.getElementById(\\\"app\\\")); \",\"html 结构\",\"<div id=\\\"app\\\"> <div>hello</div> </div> \"]},{\"header\":\"总结\",\"slug\":\"总结\",\"contents\":[\"这两个方法就可以将虚拟 DOM 挂载到页面上，下一节实现新旧虚拟 DOM 的对比，来更新视图。\"]}]},\"/vue/vue3/%E6%BA%90%E7%A0%81/watchEffect.html\":{\"title\":\"watchEffect\",\"contents\":[{\"header\":\"前言\",\"slug\":\"前言\",\"contents\":[\"在vue3的整个响应式系统中，靠的是 watchEffect函数 收集依赖，数据发生变化时触发依赖。\"]},{\"header\":\"watchEffect\",\"slug\":\"watcheffect\",\"contents\":[\"收集依赖，触发依赖\"]},{\"header\":\"思路\",\"slug\":\"思路\",\"contents\":[\"定义一个临时变量; 将传入的依赖记录到临时变量中; 执行依赖; 清空临时变量; \"]},{\"header\":\"实现\",\"slug\":\"实现\",\"contents\":[\"// 记录要收集的依赖的变量 let activeEffect; /** * @description: 收集触发依赖 * @param {function} effect 依赖 */ function watchEffect(effect) { activeEffect = effect; effect(); activeEffect = null; } \"]},{\"header\":\"dep\",\"slug\":\"dep\",\"contents\":[\"现在收集触发依赖的方法有了，就需要在访问数据时记录依赖，修改数据时触发依赖，即 getter 和 setter。\",\"每一个数据都可以是一个实例，该实例记录着与自己有关的所有依赖\",\"class Dep { constructor(value) { // 存储所有关于该数据的依赖 this.subscribers = new Set(); // 数据 this._value = value; } // getter get value() { // 访问数据时记录依赖 depend(); return this._value; } // setter set value(newValue) { this._value = newValue; // 修改数据时触发依赖 notify(); } depend() { if (activeEffect) { this.subscribers.add(activeEffect); } } notify() { this.subscribers.forEach((effect) => { effect(); }); } } \"]},{\"header\":\"结合\",\"slug\":\"结合\",\"contents\":[\"const dep = new Dep(\\\"hello\\\"); watchEffect(() => { // 访问了数据，所以该依赖被记录了 console.log(dep.value); }); // 修改数据，依赖被触发 dep.value = \\\"world\\\"; // world \"]},{\"header\":\"总结\",\"slug\":\"总结\",\"contents\":[\"本节为了理清收集触发依赖的流程，所以使用了 dep 这个类来实现逻辑，但 getter 和 setter 无法捕获引用类型数据的操作，所以下节将实现 reactive函数 来实现对引用类型数据的操作捕获。\"]}]},\"/components/\":{\"title\":\"Components\",\"contents\":[]},\"/git/\":{\"title\":\"Git\",\"contents\":[]},\"/javascript/\":{\"title\":\"Javascript\",\"contents\":[]},\"/typescript/\":{\"title\":\"Typescript\",\"contents\":[]},\"/%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF/\":{\"title\":\"业务场景\",\"contents\":[]},\"/css/\":{\"title\":\"Css\",\"contents\":[]},\"/javascript/%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/\":{\"title\":\"高阶函数\",\"contents\":[]},\"/vue/vue3/%E6%BA%90%E7%A0%81/\":{\"title\":\"源码\",\"contents\":[]},\"/vue/vue3/\":{\"title\":\"Vue3\",\"contents\":[]},\"/vue/\":{\"title\":\"Vue\",\"contents\":[]}}}");self.onmessage=({data:o})=>{self.postMessage($(o.query,m[o.routeLocale]))};
//# sourceMappingURL=original.js.map
