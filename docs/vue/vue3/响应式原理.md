---
title: 响应式原理
---

## 前言

看了袁进老师讲的《vue2响应式原理》后，终于对vue的响应式实现有了初步的了解。由于vue2使用的是 `Object.definedProperty` 实现，vue3使用 `Proxy` 实现，所以试着自己用 `Proxy` 实现一下。

## 准备

1. 定义html结构

```html
<div>姓名：<span class="name" /></div>
```

2. 定义用户信息

```js
const user = {
  name: "张三",
};
```

3. 将用户信息展示到页面

```js
function showName() {
  document.querySelector(".name").innerHTML = user.name;
}

showName();
```

## 实现

要实现响应式，就需要知道数据何时被调用、被修改，通过 `Proxy` 可实现对 `Object` 的代理。

### 1. 定义一个类似 reactive 的函数

```js
function reactive(data) {
  const proxy = new Proxy(data, {
    get(obj, prop) {
      // 访问 proxy.xxx 时，返回 data.xxx
      return obj[prop];
    },
    set(obj, prop, value) {
      // 修改 proxy.xxx 时, 修改 data.xxx
      obj[prop] = value;
      return true; // 必须要返回 ture，否则会报错
    },
  });
  return proxy;
}

const userProxy = reactive(user);
```

当对 `userProxy` 进行操作时，就可以被捕获到。

### 2. 将页面展示内容替换为代理对象

类似 `{{ userProxy.name }}` 的效果

```js
function showName() {
  // document.querySelector(".name").innerHTML = user.name;
  document.querySelector(".name").innerHTML = userProxy.name;
}

showName();
```

现在存在一个问题：当我修改 `userProxy.name` 时，页面需要更新，也就是调用 `showName` 方法。那就需要在 `setter` 中调用方法，如何知道调用哪个方法？

这里学习到vue的一个思想：

- getter 依赖收集：记录哪个函数用我
- setter 派发更新：执行用我的函数

### 3. getter 中记录哪个函数用我

怎么在 `getter` 中知道哪个函数用了我？

1. 在 `用了我的函数` 在调用前，将该函数存放到一个全局对象上
2. 调用了 `用了我的函数` 的时候，就会触发 `getter` ，将全局对象上的这个函数给记录起来
3. 调用完后，将该函数从全局对象上移除

```js
// 此处为了方便，使用了window
window.__fun = showName
showName()
window.__fun = null

function reactive(data) {
  // 使用 Set：防止记录了重复调用的函数
  const funs = new Set()
  const proxy = new Proxy(data, {
    get(obj, prop) {
      // 当前存在调用了我的函数 并且 该函数未被记录时，记录该函数
      if(window.__fun && !funs.has(window.__fun)){
        funs.add(window.__fun)
      }
      return obj[prop];
    },
    ...
  });
  return proxy;
}
```

### 4. setter 中执行用了我的函数

```js
function reactive(data) {
  // 使用 Set：防止记录了重复调用的函数
  const funs = new Set();
  const proxy = new Proxy(data, {
    // getter...
    set(obj, prop, value) {
      obj[prop] = value;
      // 执行用了我的函数
      funs.forEach((fun) => fun());
    },
  });
  return proxy;
}
```

至此，`userProxy.name` 已经可以实现响应式。

当函数首次调用时，会触发对应属性的 `getter` ，记录该函数；当对应属性被修改时，`setter` 会调用该函数，更新相关内容。

## 问题

### 1. 嵌套对象不是响应式

当 `user` 结构为嵌套对象，操作对象类型属性时，不会触发响应式。

```js
const user = {
  name: "张三",
  address: {
    city: "北京",
  },
};
```

解决方法：递归每一个对象类型的属性，将返回的代理对象赋值给当前属性

```js
function reactive(data) {
  for (let k in data) {
    if (typeof data[k] === "object") {
      data[k] = reactive(data[k]);
    }
  }

  // 使用 Set：防止记录了重复调用的函数
  const funs = new Set();
  const proxy = new Proxy(data, {
    // getter...
    // setter
  });
  return proxy;
}
```
