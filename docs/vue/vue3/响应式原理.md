---
title: 响应式原理
---

## 前言

看了袁进老师讲的《vue2响应式原理》后，终于对vue的响应式实现有了初步的了解。由于vue2使用的是 `Object.definedProperty` 实现，vue3使用 `Proxy` 实现，所以试着自己用 `Proxy` 实现一下。

## 准备

1. 定义html结构

```html
<div>姓名：<span class="name" /></div>
```

2. 定义用户信息

```js
const user = {
  name: "张三",
};
```

3. 将用户信息展示到页面

```js
function showName() {
  document.querySelector(".name").innerHTML = user.name;
}

showName();
```

## 实现

要实现响应式，就需要知道数据何时被调用、被修改，通过 `Proxy` 可实现对 `Object` 的代理。

### 1. 定义一个类似 reactive 的函数

```js
function reactive(obj) {
  const proxy = new Proxy(obj, {
    get(target, key) {
      // 返回值
      const res = Reflect.get(target, key);
      return res;
    },
    set(target, key, value) {
      // 设置值
      const res = Reflect.set(target, key, value);
      return res;
    },
  });
  return proxy;
}

const userProxy = reactive(user);
```

当对 `userProxy` 进行操作时，就可以被捕获到。

### 2. 将页面展示内容替换为代理对象

类似 `{{ userProxy.name }}` 的效果

```js
function showName() {
  // document.querySelector(".name").innerHTML = user.name;
  document.querySelector(".name").innerHTML = userProxy.name;
}

showName();
```

现在存在一个问题：当我修改 `userProxy.name` 时，页面需要更新，也就是调用 `showName` 方法。那就需要在 `setter` 中调用方法，如何知道调用哪个方法？

这里学习到vue的一个思想：

- getter 依赖收集：记录哪个函数用我
- setter 派发更新：执行用我的函数

### 3. getter 中进行依赖收集

怎么在 `getter` 中知道哪个函数用了我？

1. 在 `用了我的函数` 在调用前，将该函数存入临时函数栈中
2. 调用 `用了我的函数` 的时候，就会触发 `getter`
3. 在 `getter` 中取出临时函数栈栈顶的函数
4. 用一个 `WeakMap(类似Map,但有垃圾回收机制优势)` 记录属性与该函数的关系
5. 调用函数
6. 将该函数从临时函数栈中出栈

```js
// 临时函数栈
const effectStack = [];
// WeakMap 记录属性与依赖函数的关系
const targetMap = new WeakMap();
/*
 * 大致结构
 *  target = {  // new WeakMap()
 *    object: { // new Map()
 *      prop:new Set()  // Set中存放依赖函数
 *    }
 *    ...
 *  }
 */
```

封装一个函数：添加函数到临时函数栈中，并执行函数，出栈

```js
function effect(fn) {
  const effectFun = () => {
    // 栈中没有该函数则入栈，
    if (!effectStack.includes(effectFun)) {
      try {
        effectStack.push(effect);
        // 执行函数会触发getter，在getter中记录该函数与属性的关系
        return fn(...args);
      } finally {
        effectStack.pop();
      }
    }
  };
  effectFun();
  return effectFun;
}
```

封装收集依赖的函数

```js
function trach(target, key) {
  // 取出临时响应函数栈栈顶的函数
  const effect = effectStack[effectStack.length - 1];
  if (effect) {
    // 获取 WeakMap 的 value
    const effectObj = targetMap.get(target);
    // 没有则创建
    if (!effectObj) {
      effectObj = new Map();
      targetMap.set(target, effectObj);
    }
    // 获取 Map 的 value
    const effectKey = effectObj.get(key);
    // 没有则创建
    if (!effectKey) {
      effectKey = new Set();
      effectKey.set(key, effectKey);
    }

    // 建立属性与函数的依赖关系
    effectKey.add(effect);
  }
}
```

修改值之前进行依赖收集

```js{5}
function reactive(obj) {
  const proxy = new Proxy(obj, {
    get(target, key) {
      const res = Reflect.get(target, key);
      trach(target,key)
      return res;
    },
    // 此处省略 setter
  });
  return proxy;
}
```

### 4. setter 中进行派发更新

封装一个函数：重新执行与修改属性有关的函数

```js
function trigger(target, key) {
  const effectObj = targetMap.get(target);
  if (!effectObj) return;

  const effectFuns = effectObj.get(key);
  if (effectFuns) {
    // 执行所有有关函数
    effectFuns.forEach((fun) => fun());
  }
}
```

设置值之前进行派发更新

```js{7}
function reactive(obj) {
  const proxy = new Proxy(obj, {
    // 此处省略 getter
    set(target, key, value) {
      // 设置值
      const res = Reflect.set(target, key, value);
      trigger(target, key);
      return res;
    },
  });
  return proxy;
}
```

至此，`userProxy.name` 已经可以实现响应式。

当函数首次调用时，会触发对应属性的 `getter` ，记录该函数；当对应属性被修改时，`setter` 会调用该函数，更新相关内容。

## 问题

### 1. 嵌套对象不是响应式

当 `user` 结构为嵌套对象，操作对象类型属性时，不会触发响应式。

```js
const user = {
  name: "张三",
  address: {
    city: "北京",
  },
};
```

解决方法：当访问的属性是引用类型时，将该属性变成响应式属性返回

```js{5-7}
function reactive(obj) {
  const proxy = new Proxy(obj, {
    get(target, key) {
      const res = Reflect.get(target, key);
      if(typeof res === 'object' && res !== null){
        res = reactive(res)
      }
      trach(target,key)
      return res;
    },
    // 此处省略 setter
  });
  return proxy;
}
```
